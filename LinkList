package LinkList;

class ListNode{
	public ListNode next;
	public int val;
	public ListNode(int val) {
		this.val=val;
	}
}

public class LinkList{
	public ListNode head;
	public int length=0;
	//打印链表
	public void printLinkList()
	{
		ListNode p=head;
		while(p!=null)
		{
			System.out.println(p.val);
			p=p.next;
		}
		System.out.println("长度为："+length);
	}
	//判断链表是否为空
	public Boolean isEmpty()
	{
		if(head==null)
			return true;
		return false;
	}
	//尾插法添加结点
	public void addLastNode(int val)
	{
		ListNode x=new ListNode(val);
		if(head==null)
		{
			head=x;
			length++;
			return;
		}
		ListNode q=head;
		while(q.next!=null)
			q=q.next;
		q.next=x;
		length++;
	}
	//头插法添加结点
	public void addHeadNode(int val)
	{
		ListNode x=new ListNode(val);
		if(head==null)
		{
			head=x;
			length++;
			return;
		}
		x.next=head;
		head=x;
		length++;
	}
	//删除结点
	public Boolean deleteNode(int index)
	{
		if(index<1||index>length)
			return false;
		int i=1;
		ListNode p=head;
		while(i!=(index-1))
		{
			p=p.next;
			i++;
		}
		(p.next)=(p.next.next);
		length--;
		return true;
	}
	//修改结点
	public Boolean updateNode(int index,int val)
	{
		if(index<1||index>length)
			return false;
		int i=1;
		ListNode p=head;
		while(i<index)
		{
			p=p.next;
			i++;
		}
		p.val=val;
		return true;
	}
	//向前冒泡，因为冒泡是相邻俩俩进行比较，
	//当一轮排序发现顺序没有改变则数列已经有序
	public void SortLinkList()
	{
		Boolean flag=false;
		ListNode p=head;
		ListNode q=null;
		for(int i=0;i<length-1;i++)
		{
			q=p.next;
			for(int j=i;j<length-1;j++)
			{
				if(p.val>q.val)
				{
					int t=p.val;
					p.val=q.val;
					q.val=t;
					flag=true;
				}
				q=q.next;
			}
			if(flag==false)
				break;
			flag=false;
			p=p.next;
		}
	}
}

